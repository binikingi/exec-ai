#!/usr/bin/env bash

# exec-ai: AI-powered command line assistant
# Usage: ?? <your command description>

set -e

VERSION="1.0.1"
SCRIPT_NAME="exec-ai"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Configuration
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/exec-ai"
CONFIG_FILE="$CONFIG_DIR/config"
HISTORY_FILE="$CONFIG_DIR/history"

# Create config directory if it doesn't exist
mkdir -p "$CONFIG_DIR"

# Function to print colored output
print_color() {
    local color=$1
    shift
    echo -e "${color}$*${NC}"
}

# Function to show loading animation
show_loading() {
    local pid=$1
    local delay=0.1
    local spinstr='|/-\\'

    # Use kill -0 to check if process exists (more portable)
    while kill -0 $pid 2>/dev/null; do
        local temp=${spinstr#?}
        printf "\r${CYAN}%c${NC} Thinking..." "$spinstr"
        local spinstr=$temp${spinstr%"$temp"}
        sleep $delay
    done
    printf "\r%-30s\r" " "
}

# Function to detect current shell
detect_shell() {
    if [ -n "$FISH_VERSION" ]; then
        echo "fish"
    elif [ -n "$ZSH_VERSION" ]; then
        echo "zsh"
    elif [ -n "$BASH_VERSION" ]; then
        echo "bash"
    else
        # Fallback to parent process name
        ps -p $$ -o comm= | xargs basename
    fi
}

# Function to get API key
get_api_key() {
    if [ -n "$ANTHROPIC_API_KEY" ]; then
        echo "$ANTHROPIC_API_KEY"
    elif [ -f "$CONFIG_FILE" ]; then
        grep "^ANTHROPIC_API_KEY=" "$CONFIG_FILE" | cut -d'=' -f2
    else
        echo ""
    fi
}

# Function to set API key
set_api_key() {
    local key=$1
    echo "ANTHROPIC_API_KEY=$key" > "$CONFIG_FILE"
    chmod 600 "$CONFIG_FILE"
    print_color "$GREEN" "API key saved to $CONFIG_FILE"
}

# Function to gather system context
gather_system_context() {
    local os_type=$(uname -s)
    local os_version=$(uname -r)
    local architecture=$(uname -m)
    local current_dir=$(pwd)
    local user=$(whoami)

    # Check for common tools
    local has_docker=""
    local has_git=""
    local has_python=""
    local has_node=""

    command -v docker &> /dev/null && has_docker="yes"
    command -v git &> /dev/null && has_git="yes"
    command -v python3 &> /dev/null && has_python="yes"
    command -v node &> /dev/null && has_node="yes"

    # Build context string
    local context="System: $os_type $os_version ($architecture)"
    context="$context\nCurrent directory: $current_dir"
    context="$context\nUser: $user"

    if [ -n "$has_docker" ]; then
        context="$context\nDocker: available"
    fi
    if [ -n "$has_git" ]; then
        context="$context\nGit: available"
    fi
    if [ -n "$has_python" ]; then
        local py_version=$(python3 --version 2>&1 | cut -d' ' -f2)
        context="$context\nPython: $py_version"
    fi
    if [ -n "$has_node" ]; then
        local node_version=$(node --version 2>&1)
        context="$context\nNode.js: $node_version"
    fi

    echo "$context"
}

# Function to call Claude API
call_claude_api() {
    local prompt=$1
    local shell=$2
    local api_key=$3
    local error_context=${4:-""}

    # Gather system context
    local sys_context=$(gather_system_context)

    local system_prompt="You are a helpful command line assistant. The user is using $shell shell. Generate ONLY the exact command needed to accomplish the task. Do not include explanations, markdown formatting, or code blocks. Output only the raw command that can be executed directly. Be precise and safe. make sure that if the user wants to do somehting to that requires more than 1 command to return a 1-liner using && or ; to chain commands. your output should be a single line command that can be run directly in the terminal.\n\nSystem Context:\n$sys_context"

    # Build user message with optional error context
    local user_message="$prompt"
    if [ -n "$error_context" ]; then
        user_message="$user_message\n\nPrevious attempt failed with:\n$error_context\n\nPlease provide a corrected command."
    fi

    local response=$(curl -s https://api.anthropic.com/v1/messages \
        -H "content-type: application/json" \
        -H "x-api-key: $api_key" \
        -H "anthropic-version: 2023-06-01" \
        -d "{
            \"model\": \"claude-haiku-4-5-20251001\",
            \"max_tokens\": 1024,
            \"system\": \"$system_prompt\",
            \"messages\": [{
                \"role\": \"user\",
                \"content\": \"$user_message\"
            }]
        }")

    # Extract the command from the response using Python for reliable JSON parsing
    echo "$response" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data['content'][0]['text'].strip())" 2>/dev/null || echo ""
}

# Function to execute command with approval
execute_with_approval() {
    local command=$1
    local auto_approve=${2:-false}
    local query=${3:-""}
    local shell=${4:-"bash"}
    local api_key=${5:-""}

    # Show the proposed command
    print_color "$CYAN" "\nI want to run this command:"
    print_color "$YELLOW" "  $command"
    echo ""

    local approval_lower=""

    # Check if auto-approve is enabled
    if [ "$auto_approve" = true ]; then
        print_color "$GREEN" "Auto-approving with -y flag..."
        approval_lower="y"
    else
        # Ask for approval
        echo -n "Do you approve? [Y]es/[n]o: "
        read -r approval

        # Convert to lowercase for case-insensitive comparison (compatible with older bash)
        approval_lower=$(echo "$approval" | tr '[:upper:]' '[:lower:]')
    fi

    case "$approval_lower" in
        y|yes|"")
            print_color "$GREEN" "\nExecuting..."
            echo ""

            # Save to history
            echo "$(date '+%Y-%m-%d %H:%M:%S') | $command" >> "$HISTORY_FILE"

            # Capture both stdout and stderr
            local temp_output=$(mktemp)
            local temp_error=$(mktemp)

            # Execute the command (disable set -e temporarily to capture exit code)
            set +e
            eval "$command" > "$temp_output" 2> "$temp_error"
            local exit_code=$?
            set -e

            # Display output
            cat "$temp_output"
            cat "$temp_error" >&2

            echo ""
            if [ $exit_code -eq 0 ]; then
                print_color "$GREEN" "Command completed successfully."
                rm "$temp_output" "$temp_error"
            else
                print_color "$RED" "Command failed with exit code: $exit_code"

                # Offer to retry with AI help
                if [ -n "$query" ] && [ -n "$api_key" ]; then
                    echo ""
                    echo -n "Do you want to send the error to AI and try a corrected command? [Y]es/[n]o: "
                    read -r retry_approval

                    retry_approval=$(echo "$retry_approval" | tr '[:upper:]' '[:lower:]')

                    if [ "$retry_approval" = "y" ] || [ "$retry_approval" = "yes" ] || [ -z "$retry_approval" ]; then
                        # Build error context
                        local error_output=$(cat "$temp_error")
                        local error_context="Command: $command\nExit code: $exit_code\nError output:\n$error_output"

                        print_color "$CYAN" "\nAsking AI for a corrected command..."

                        # Call Claude API with error context
                        local temp_file=$(mktemp)
                        (call_claude_api "$query" "$shell" "$api_key" "$error_context" > "$temp_file") &
                        local api_pid=$!

                        # Show loading animation
                        show_loading $api_pid
                        wait $api_pid

                        # Get the corrected command
                        local corrected_command=$(cat "$temp_file")
                        rm "$temp_file"

                        # Check if we got a valid response
                        if [ -n "$corrected_command" ]; then
                            # Recursively call execute_with_approval with the corrected command
                            execute_with_approval "$corrected_command" false "$query" "$shell" "$api_key"
                            local retry_exit_code=$?
                            rm "$temp_output" "$temp_error"
                            return $retry_exit_code
                        else
                            print_color "$RED" "Failed to get corrected command from AI."
                        fi
                    fi
                fi

                rm "$temp_output" "$temp_error"
            fi

            return $exit_code
            ;;
        *)
            print_color "$YELLOW" "Command cancelled."
            return 1
            ;;
    esac
}

# Function to show help
show_help() {
    cat << EOF
${SCRIPT_NAME} v${VERSION} - AI-powered command line assistant

Usage:
  ?? <description>          Generate and execute a command
  ?? -y <description>       Auto-approve and execute without confirmation
  ?? --setup               Configure API key
  ?? --history             Show command history
  ?? --help                Show this help message
  ?? --version             Show version information

Examples:
  ?? list all running docker containers
  ?? find large files in current directory
  ?? create a git branch named feature-x
  ?? help me run pnpm prisma generate inside docker container named server
  ?? -y show disk usage sorted by size

Configuration:
  API Key: Set ANTHROPIC_API_KEY environment variable or use --setup

EOF
}

# Function to show history
show_history() {
    if [ -f "$HISTORY_FILE" ]; then
        print_color "$CYAN" "Command History:"
        cat "$HISTORY_FILE" | tail -20
    else
        print_color "$YELLOW" "No command history found."
    fi
}

# Main function
main() {
    local auto_approve=false

    # Handle special flags
    case "${1:-}" in
        --help|-h)
            show_help
            exit 0
            ;;
        --version|-v)
            echo "$SCRIPT_NAME v$VERSION"
            exit 0
            ;;
        --setup)
            echo -n "Enter your Anthropic API key: "
            read -r api_key
            set_api_key "$api_key"
            exit 0
            ;;
        --history)
            show_history
            exit 0
            ;;
        "")
            print_color "$RED" "Error: No command description provided"
            echo "Usage: ?? <description>"
            echo "Try '?? --help' for more information"
            exit 1
            ;;
    esac

    # Check for -y flag (auto-approve)
    if [ "$1" = "-y" ]; then
        auto_approve=true
        shift
    fi

    # Get the user's query
    local query="$*"

    # Check for API key
    local api_key=$(get_api_key)
    if [ -z "$api_key" ]; then
        print_color "$RED" "Error: No API key found"
        print_color "$YELLOW" "Please set ANTHROPIC_API_KEY environment variable or run: ?? --setup"
        exit 1
    fi

    # Detect shell
    local shell=$(detect_shell)

    # Call Claude API in background
    local temp_file=$(mktemp)
    (call_claude_api "$query" "$shell" "$api_key" > "$temp_file") &
    local api_pid=$!

    # Show loading animation (with "Thinking..." message)
    show_loading $api_pid
    wait $api_pid

    # Get the generated command
    local command=$(cat "$temp_file")
    rm "$temp_file"

    # Check if we got a valid response
    if [ -z "$command" ]; then
        print_color "$RED" "Error: Failed to generate command. Please check your API key and try again."
        exit 1
    fi

    # Execute with approval
    execute_with_approval "$command" "$auto_approve" "$query" "$shell" "$api_key"
}

# Run main function
main "$@"
